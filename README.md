# SolidCore

[![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://img.shields.io/github/license/gvatsal60/Solidcore)
[![build status](https://github.com/gvatsal60/Solidcore/actions/workflows/readme-checker.yaml/badge.svg)](https://github.com/gvatsal60/Solidcore/actions/workflows/readme-checker.yaml)
[![pre-commit.ci status](https://results.pre-commit.ci/badge/github/gvatsal60/Solidcore/master.svg)](https://results.pre-commit.ci/latest/github/gvatsal60/Solidcore/HEAD)
![GitHub pull-requests](https://img.shields.io/github/issues-pr/gvatsal60/Solidcore)
![GitHub Issues](https://img.shields.io/github/issues/gvatsal60/Solidcore)
![GitHub forks](https://img.shields.io/github/forks/gvatsal60/Solidcore)
![GitHub stars](https://img.shields.io/github/stars/gvatsal60/Solidcore)

## Installation

To install Project Template, follow these steps:

1. **Clone the repository:**

   ```bash
   git clone https://github.com/gvatsal60/Solidcore.git
   cd Solidcore
   ```

## Introduction

The SOLID principles are a set of design principles that make object-oriented design more understandable, flexible, and maintainable.
These principles were introduced by Robert C. Martin and are foundational for writing robust software. They help developers create systems that are easy to manage and extend.

The SOLID Principles

### 1. Single Responsibility Principle (SRP)

**Simple Explanation**: I will focus solely on the tasks and responsibilities that align with my skills and expertise.

**Definition**: A class should have only one reason to change. In other words, a class should have only one job or responsibility.

**Purpose**: By adhering to SRP, you ensure that your classes are modular and focused. This makes it easier to maintain and modify them without affecting other parts of the system.

### 2. Open/Closed Principle (OCP)

**Simple Explanation**: I‚Äôm open to taking on additional tasks or responsibilities, but I will continue to fulfill my existing work commitments.

**Definition**: Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.

**Purpose**: This principle helps to extend the functionality of a system without altering existing code, thus reducing the risk of introducing bugs.

### 3. Liskov Substitution Principle (LSP)

**Simple Explanation**: At some point, every child must take on responsibilities that were previously handled by their parents.

**Definition**: Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.

**Purpose**: This principle ensures that a subclass can stand in for its superclass without unexpected behavior, promoting a more reliable and predictable system.

### 4. Interface Segregation Principle (ISP)

**Simple Explanation**: I will focus on tasks I‚Äôm skilled at and won‚Äôt take on tasks outside my expertise.

**Definition**: Clients should not be forced to depend on interfaces they do not use.

**Purpose**: This principle advocates for creating small, specific interfaces rather than a large, general-purpose one. This leads to more modular and easy-to-understand code.

### 5. Dependency Inversion Principle (DIP)

**Simple Explanation**: I can handle any task on my own and shouldn‚Äôt rely on others.

**Definition**: High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.

**Purpose**: This principle helps in reducing the coupling between high-level and low-level components by introducing abstractions, making the system more flexible and easier to manage.

## KISS Principle (Keep It Simple, Stupid)

**Definition**: The KISS principle is a reminder to keep your designs as simple as possible. Avoid complexity and unnecessary complications.

**Purpose**: Simplicity in design leads to more understandable and maintainable code. This principle encourages developers to avoid over-engineering and focus on straightforward solutions.

**Sarcastic Note**: Because who doesn‚Äôt love a good spaghetti code mess? If you‚Äôre into writing cryptic code that takes a PhD to decipher, by all means, ignore the KISS principle.
After all, who needs simplicity when you can have complexity? üòè

## Contributing

Contributions are welcome! Please read our
[Contribution Guidelines](https://github.com/gvatsal60/Solidcore/blob/HEAD/CONTRIBUTING.md)
before submitting pull requests.

## License

This project is licensed under the Apache License 2.0 License - see the
[LICENSE](https://github.com/gvatsal60/Solidcore/blob/HEAD/LICENSE) file for details.
